<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白开水船长</title>
  
  <subtitle>东隅已逝，桑榆非晚</subtitle>
  <link href="https://cq230.github.io/atom.xml" rel="self"/>
  
  <link href="https://cq230.github.io/"/>
  <updated>2024-12-20T12:23:59.839Z</updated>
  <id>https://cq230.github.io/</id>
  
  <author>
    <name>Ryan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-this和super</title>
    <link href="https://cq230.github.io/posts/13fbb470.html"/>
    <id>https://cq230.github.io/posts/13fbb470.html</id>
    <published>2022-03-25T11:20:34.000Z</published>
    <updated>2024-12-20T12:23:59.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h5 id="1-可以用来修饰或调用："><a href="#1-可以用来修饰或调用：" class="headerlink" title="1.可以用来修饰或调用："></a>1.可以用来修饰或调用：</h5><p>属性、方法、构造器</p><h5 id="2-this修饰属性和方法时："><a href="#2-this修饰属性和方法时：" class="headerlink" title="2.this修饰属性和方法时："></a>2.this修饰属性和方法时：</h5><p>this理解为：当前对象或者当前正在创建的对象（this.表示先在本类中查找，找不到再去父类找）</p><p>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时（例如set方法），我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p><p>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p><h5 id="3-this调用构造器时："><a href="#3-this调用构造器时：" class="headerlink" title="3.this调用构造器时："></a>3.this调用构造器时：</h5><p>我们在类的构造器中，可以显式的使用”this(形参列表)”的方式，调用本类中指定的<strong>其他</strong>构造器；</p><p>构造器中不能通过”this(形参列表)”的方式调用自己；</p><p>如果一个类中有n个构造器，则最多有<strong>n-1</strong>个构造器中使用了”this(形参列表)”,至少<strong>1</strong>个使用”super(形参列表)”；</p><p>规定：”this(形参列表)”必须声明在当前构造器的<strong>首行</strong>,所以一个构造器内部最多只能声明一个”this(形参列表)”，用来调用其他的构造器；</p><p>注意调用逻辑不能陷入死循环。</p><h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><ol><li><h6 id="super理解为：父类的…"><a href="#super理解为：父类的…" class="headerlink" title="super理解为：父类的…"></a>super理解为：父类的…</h6></li><li><p>super(形参列表)指调用父类对应的构造器，也必须声明在当前构造器<strong>首行</strong>；</p></li><li><p>因此在类的构造器中”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现；</p></li><li><p>在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则<strong>默认</strong>调用的是父类中空参构造器:super()</p></li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h1><p>类的构造器首行不是”this(形参列表)”就是”super(形参列表)”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;h5 id=&quot;1-可以用来修饰或调用：&quot;&gt;&lt;a href=&quot;#1-可以用来修饰或调用：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Java-static</title>
    <link href="https://cq230.github.io/posts/80c02825.html"/>
    <id>https://cq230.github.io/posts/80c02825.html</id>
    <published>2022-03-13T09:43:32.000Z</published>
    <updated>2024-12-20T10:59:18.425Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-静态方法调用"><a href="#1-静态方法调用" class="headerlink" title="1.静态方法调用"></a>1.静态方法调用</h4><p>直接 <em>类名.方法名</em> 调用</p><h4 id="2-非静态方法调用"><a href="#2-非静态方法调用" class="headerlink" title="2.非静态方法调用"></a>2.非静态方法调用</h4><p>需要实例化对应的类来调用</p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h4><ul><li><p>因为static和非static类型的方法加载时间不同，因此static类型的方法<strong>无法</strong>调用<strong>非static类型的方法或属性</strong></p></li><li><p>创建了类的多个对象后，多个对象<strong>共享</strong>同一个静态变量；当某一个对象修改了该静态变量后，会导致其他对象<strong>再</strong>调用该静态变量时，是修改过的。（在修改之前调用静态变量则是修改之前的值）</p></li><li><p>static方法中，不能使用this、super关键字</p></li><li><p>static类型的结构随着类的加载而加载</p></li><li><p>静态结构前没有声明的都是省略的 <strong>“类名.”</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-静态方法调用&quot;&gt;&lt;a href=&quot;#1-静态方法调用&quot; class=&quot;headerlink&quot; title=&quot;1.静态方法调用&quot;&gt;&lt;/a&gt;1.静态方法调用&lt;/h4&gt;&lt;p&gt;直接 &lt;em&gt;类名.方法名&lt;/em&gt; 调用&lt;/p&gt;
&lt;h4 id=&quot;2-非静态方法调用&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Java-函数式接口</title>
    <link href="https://cq230.github.io/posts/23e07c64.html"/>
    <id>https://cq230.github.io/posts/23e07c64.html</id>
    <published>2022-02-24T12:08:43.000Z</published>
    <updated>2024-12-20T12:23:59.843Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</p><p>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p><p>在 java.util.function 包下定义了Java 8 的丰富的函数式接口</p><ul><li>Java从诞生日起就是一直倡导“一切皆对象”，在 Java 里面面向对象(OOP)编程是一切。但是随着 python、scala 等语言的兴起和新技术的挑战，Java 不得不做出调整以便支持更加广泛的技术要求，也即 java 不但可以支持 OOP 还可以支持 OOF（面向函数编程）</li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda 表达式的类型是函数。但是在 Java8 中，有所不同。在 Java8 中，Lambda 表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li><li>简单的说，在 Java8 中，Lambda 表达式就是一个函数式接口的实例。这就是 Lambda 表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示。<br>所以以前用匿名实现类表示的现在都可以用 Lambda 表达式来写。</li></ul><h6 id="Java内置的函数式接口介绍及使用举例"><a href="#Java内置的函数式接口介绍及使用举例" class="headerlink" title="Java内置的函数式接口介绍及使用举例"></a>Java内置的函数式接口介绍及使用举例</h6><blockquote><p>[!NOTE]</p><p> 前4种为 Java 内置的四大核心函数式接口</p></blockquote><table><thead><tr><th align="center">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><strong>Consumer 消费型接口</strong></td><td align="center">T</td><td align="center">void</td><td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td></tr><tr><td align="center"><strong>Supplier 供给型接口</strong></td><td align="center">无</td><td align="center">T</td><td align="center">返回类型为T的对象，包含方法：T get()</td></tr><tr><td align="center"><strong>Function&lt;T, R&gt; 函数型接口</strong></td><td align="center">T</td><td align="center">R</td><td align="center">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)</td></tr><tr><td align="center"><strong>Predicate 断定型接口</strong></td><td align="center">T</td><td align="center">boolean</td><td align="center">确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t)</td></tr><tr><td align="center">BiFunction&lt;T,U,R&gt;</td><td align="center">T, U</td><td align="center">R</td><td align="center">对类型为T,U参数应用操作，返回R类型的结果。包含方法为：Rapply(T t,U u);</td></tr><tr><td align="center">UnaryOperator(Function子接口)</td><td align="center">T</td><td align="center">T</td><td align="center">对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：Tapply(T t);</td></tr><tr><td align="center">BinaryOperator(BiFunction子接口)</td><td align="center">T,T</td><td align="center">T</td><td align="center">对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：Tapply(T t1,T t2);</td></tr><tr><td align="center">BiConsumer&lt;T,U&gt;</td><td align="center">T,U</td><td align="center">void</td><td align="center">对类型为T,U参数应用操作。包含方法为：voidaccept(Tt,Uu)</td></tr><tr><td align="center">BiPredicate&lt;T,U&gt;</td><td align="center">T,U</td><td align="center">boolean</td><td align="center">包含方法为：booleantest(Tt,Uu)</td></tr><tr><td align="center">ToIntFunction</td><td align="center">T</td><td align="center">int</td><td align="center">计算int值的函数</td></tr><tr><td align="center">ToLongFunction</td><td align="center">T</td><td align="center">long</td><td align="center">计算long值的函数</td></tr><tr><td align="center">ToDoubleFunction</td><td align="center">T</td><td align="center">double</td><td align="center">计算double值的函数</td></tr><tr><td align="center">IntFunction</td><td align="center">int</td><td align="center">R</td><td align="center">参数为int类型的函数</td></tr><tr><td align="center">LongFunction</td><td align="center">long</td><td align="center">R</td><td align="center">参数为long类型的函数</td></tr><tr><td align="center">DoubleFunction</td><td align="center">double</td><td align="center">R</td><td align="center">参数为double类型的函数</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。&lt;/p&gt;
&lt;p&gt;我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。&lt;/p&gt;
&lt;p&gt;在 java.util.function 包下定义了Java 8 </summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-lambda</title>
    <link href="https://cq230.github.io/posts/328883ce.html"/>
    <id>https://cq230.github.io/posts/328883ce.html</id>
    <published>2022-02-24T11:32:57.000Z</published>
    <updated>2024-12-20T12:23:59.838Z</updated>
    
    <content type="html"><![CDATA[<p>lambda 表达式的本质：作为<strong>函数式接口</strong>的实例（即该接口的匿名实现类的对象）</p><h5 id="Lambda-表达式的使用一："><a href="#Lambda-表达式的使用一：" class="headerlink" title="Lambda 表达式的使用一："></a>Lambda 表达式的使用一：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda表达式的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class="line"><span class="comment"> * 2.格式：</span></span><br><span class="line"><span class="comment"> *      -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class="line"><span class="comment"> *      -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class="line"><span class="comment"> *      -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3.Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    总结：</span></span><br><span class="line"><span class="comment"> *    -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</span></span><br><span class="line"><span class="comment"> *    -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;长安欢迎您&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;长安欢迎您&quot;</span>);</span><br><span class="line"></span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;善与恶的区别是什么？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c1.accept(<span class="string">&quot;先天人性无善恶,后天人性有善恶。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c1.accept(<span class="string">&quot;先天人性无善恶,后天人性有善恶。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; c2 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c2.accept(<span class="string">&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Lambda-表达式的使用二："><a href="#Lambda-表达式的使用二：" class="headerlink" title="Lambda 表达式的使用二："></a>Lambda 表达式的使用二：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda表达式的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class="line"><span class="comment"> * 2.格式：</span></span><br><span class="line"><span class="comment"> *      -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class="line"><span class="comment"> *      -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class="line"><span class="comment"> *      -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3.Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    总结：</span></span><br><span class="line"><span class="comment"> *    -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</span></span><br><span class="line"><span class="comment"> *    -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; c1 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c1.accept(<span class="string">&quot;先天人性无善恶,后天人性有善恶。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; c2 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c2.accept(<span class="string">&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(c1.compare(<span class="number">15</span>,<span class="number">23</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">16</span>,<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当Lambda体只有一条语句时，return与大括号若有，都可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; c1 = (o1,o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(c1.compare(<span class="number">16</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; c2 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">        System.out.println(c2.compare(<span class="number">17</span>,<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; c1 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        c1.accept(<span class="string">&quot;先天人性无善恶,后天人性有善恶。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; c2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line">        c2.accept(<span class="string">&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;lambda 表达式的本质：作为&lt;strong&gt;函数式接口&lt;/strong&gt;的实例（即该接口的匿名实现类的对象）&lt;/p&gt;
&lt;h5 id=&quot;Lambda-表达式的使用一：&quot;&gt;&lt;a href=&quot;#Lambda-表达式的使用一：&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-注解</title>
    <link href="https://cq230.github.io/posts/461a3f3a.html"/>
    <id>https://cq230.github.io/posts/461a3f3a.html</id>
    <published>2022-02-04T12:21:30.000Z</published>
    <updated>2024-12-20T12:23:59.847Z</updated>
    
    <content type="html"><![CDATA[<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p>参照 @SuppressWarnings 定义</p><ol><li><p>注解声明为 @interface</p></li><li><p>内部定义成员，通常使用value</p></li><li><p>可以指定成员的默认值，使用default定义</p></li><li><p>如果自定义注解没有成员，表明是一个标识作用；</p><p>如果有成员，在使用注解时，需要指明成员的值（有默认值不用）</p></li><li><p>自定义注解通常都会指定两个元注解：Retention、Target</p></li></ol><h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><ul><li>Retention：指定所修饰的Annotation 的生命周期：SOURCE\CLASS(默认行为)\RUNTIME，只有声明为 <strong>RUNTIME</strong>  的注解才能通过反射获取。</li><li>Target：用于指定被修饰的Annotation能用于修饰哪些程序元素</li><li>Documented：表示所修饰的注解在被javadoc解析时，保留下来</li><li>Inherited：被它修饰的Annotation将具有继承性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;自定义注解&quot;&gt;&lt;a href=&quot;#自定义注解&quot; class=&quot;headerlink&quot; title=&quot;自定义注解&quot;&gt;&lt;/a&gt;自定义注解&lt;/h5&gt;&lt;p&gt;参照 @SuppressWarnings 定义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注解声明为 @interface&lt;/</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-interface</title>
    <link href="https://cq230.github.io/posts/9a542ee1.html"/>
    <id>https://cq230.github.io/posts/9a542ee1.html</id>
    <published>2021-12-30T09:16:24.000Z</published>
    <updated>2024-12-20T10:52:05.840Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义接口：定义接口中的成员</p><p><del>JDK7及以前：接口中只能定义全局常量和抽象方法：</del></p><p><del><strong>全局常量</strong>：public static final 的，但是在接口中书写时，可以省略不写；</del></p><p><del><strong>抽象方法</strong>：public abstract 的。</del></p><p>JDK8：除了全局常量和抽象方法，还可以定义静态方法、默认方法，二者可以<strong>有方法体</strong>：</p><ul><li><p><strong>静态方法：</strong>只能通过接口来调用；</p></li><li><p><strong>默认方法：</strong></p><ul><li><p>通过<strong>实现类的对象</strong>，可以调用接口中的<strong>默认方法</strong>；如果实现类重写了接口中的默认方法，调用时仍然调用的是重写后的方法；</p></li><li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类在没有重写此方法的情况下会报错。——&gt; <strong>接口冲突</strong>。这就需要我们在实现类中重写此方法；</p></li><li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数方法。——&gt;<strong>类优先原则</strong></p><p> 注意：类优先原则<strong>仅针对方法</strong>，不包括属性，见下方面试题1</p></li><li><p><strong>规定</strong>：在子类（或实现类）的方法中可以调用父类、接口中<strong>被子类重写</strong>的方法，语法如下（见代码演示1）：</p><p> ​super.testFunc();            &#x2F;&#x2F;调用父类中声明的方法</p><p> ​接口.super.testFunc();   &#x2F;&#x2F; 调用接口中声明的默认方法</p></li><li><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=359&share_source=copy_web">静态方法及默认方法讲解视频</a></p></li></ul></li></ul></li><li><p>接口中<strong>不能定义构造器</strong>，意味着接口不能被实例化；</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用；</p></li><li><p>如果一个实现类中覆盖了接口中的<strong>所有</strong>抽象方法，则此实现类<strong>可以</strong>被实例化；</p><p>如果实现类没有覆盖接口中的所有抽象方法，则此实现类<strong>仍为一个抽象类</strong>。</p></li><li><p>Java<strong>类可以实现多个接口</strong> —&gt; 弥补了Java单继承的局限性；</p><p>格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以<strong>多继承</strong>；</p></li><li><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=354&share_source=copy_web">接口的四种实现方式：</a>（匿名类与匿名对象）</p></li></ol><h4 id="接口面试题："><a href="#接口面试题：" class="headerlink" title="接口面试题："></a>接口面试题：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(x); //编译不通过，对 &#x27;x&#x27; 的引用不明确，&#x27;B.x&#x27; 和 &#x27;A.x&#x27; 均匹配</span></span><br><span class="line"></span><br><span class="line">        System.out.println(A.x); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.x); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>().myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>); <span class="comment">// A 重写了此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        testFunc();         <span class="comment">// A (调用的是自己重写后的方法)</span></span><br><span class="line">        <span class="built_in">super</span>.testFunc();   <span class="comment">// B (调用的是父类中被重写的方法)</span></span><br><span class="line">        C.<span class="built_in">super</span>.testFunc(); <span class="comment">// C (调用的是接口中被重写的方法)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> &#123;</span><br><span class="line">     <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义接口：定义接口中的成员&lt;/p&gt;
&lt;p&gt;&lt;del&gt;JDK7及以前：接口中只能定义全局常量和抽象方法：&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;&lt;strong&gt;全局常量&lt;/strong&gt;：public static final 的，但是在接口中书写时，可以省略</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Java-finally</title>
    <link href="https://cq230.github.io/posts/21be66c9.html"/>
    <id>https://cq230.github.io/posts/21be66c9.html</id>
    <published>2021-12-22T11:10:03.000Z</published>
    <updated>2024-12-20T12:23:59.836Z</updated>
    
    <content type="html"><![CDATA[<h6 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h6><ol><li>即使catch中又出现了异常，try或者catch中有return语句时，finally里的语句都会执行；</li><li>如果操作系统中断了我们的程序，那么finally 代码块可能就不能被执行。也有很多其他类似的行为导致 finally代码块<strong>不被执行</strong>，比如：<ul><li>调用System.exit函数</li><li>调用halt函数</li><li>守护线程，如果守护线程刚开始执行到 finally 代码块，此时没有任何其他非守护线程，那么虚拟机将退出，此时 JVM 不会等待守护线程的 finally 代码块执行完成。</li><li>Try 代码块出现无限循环，且不出现异常，finally 也将永远得不到执行。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;注意事项：&quot;&gt;&lt;a href=&quot;#注意事项：&quot; class=&quot;headerlink&quot; title=&quot;注意事项：&quot;&gt;&lt;/a&gt;注意事项：&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;即使catch中又出现了异常，try或者catch中有return语句时，finally里的语句都会执行</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Java-构造方法</title>
    <link href="https://cq230.github.io/posts/ad6bb534.html"/>
    <id>https://cq230.github.io/posts/ad6bb534.html</id>
    <published>2021-10-24T12:04:24.000Z</published>
    <updated>2024-12-20T12:23:59.846Z</updated>
    
    <content type="html"><![CDATA[<ol><li>和类名相同</li><li>没有返回值</li><li>每个类都会默认隐式存在一个无参构造方法，因此可以直接通过 “new 类名()”来创建一个对象</li><li>默认的构造器权限修饰符取决于该类的权限修饰符</li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li>new关键字本质上是在调用构造方法</li><li>可以初始化对象的值</li></ol><h5 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h5><ol><li><p>可以通过有参构造方法的参数来初始化对象的属性</p></li><li><p>在创建有参构造方法前，必须<strong>显式定义</strong>一个无参构造方法,否则没有无参构造器</p></li><li><p>有参构造方法可以重载，程序如何选取取决于创建对象时对应的参数</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;和类名相同&lt;/li&gt;
&lt;li&gt;没有返回值&lt;/li&gt;
&lt;li&gt;每个类都会默认隐式存在一个无参构造方法，因此可以直接通过 “new 类名()”来创建一个对象&lt;/li&gt;
&lt;li&gt;默认的构造器权限修饰符取决于该类的权限修饰符&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;作用&quot;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-String</title>
    <link href="https://cq230.github.io/posts/7807cbd3.html"/>
    <id>https://cq230.github.io/posts/7807cbd3.html</id>
    <published>2021-10-24T11:34:30.000Z</published>
    <updated>2024-12-20T12:23:59.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-中-String、StringBuffer、StringBuilder-的区别"><a href="#Java-中-String、StringBuffer、StringBuilder-的区别" class="headerlink" title="Java 中 String、StringBuffer、StringBuilder 的区别"></a>Java 中 String、StringBuffer、StringBuilder 的区别</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>String 是 Java 中很常用的类之一，同时，字符串是 Java 面试中最重要的话题之一。</p><p>StringBuffer 和 StringBuilder 类提供了操作字符串的方法。</p><p>我们将研究 StringBuffer 和 StringBuilder 之间的区别。</p><p>StringBuffer 与 StringBuilder 的区别是 Java 中很常见的面试题。</p><p>在控制台上打印程序的内容，可以使用 String。此博客介绍 String 类的主要功能，然后我们将比较 StringBuffer 和 StringBuilder 类。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>因为 String 是 final 修饰的，无法被继承。所以 <strong>String 不是 Java 的基本数据类型</strong>。<br>字符串在 Java 中是不可变的，因此适合在多线程环境下使用。<br>当我们使用双引号创建一个字符串时，如下，JVM 首先在字符串池中寻找具有相同值的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ABC&quot;;</span><br></pre></td></tr></table></figure><p>如果找到了，它将返回字符串池中的字符串对象的引用。否则，它会在字符串池中创建字符串对象并返回引用。JVM 通过在不同的线程中使用相同的字符串，节省了大量的内存。</p><p>如果使用 new 运算符创建字符串，则会在堆中创建它。</p><p>运算符 <code>+</code> 是为 String 重载的，我们可以用它来串联两个字符串。尽管在内部它使用 StringBuilder 来执行这个动作。</p><p>两个字符串只有在它们具有相同字符串的时候才相等，equals() 方法区分大小写。如果您正在寻找不区分大小写的检查，您应该使用 equalsIgnoreCase() 方法。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>由于 String 在 Java 中是不可变的，因此每当我们执行字符串拼接操作时，它都会生成一个新的 String 并丢弃旧的 String 以进行垃圾收集。<br>这些重复的操作会在堆中产生大量垃圾冗余。所以 Java 提供了 StringBuffer 和 StringBuilder 类，应该用于字符串操作。<br>StringBuffer 和 StringBuilder 是 Java 中的可变对象。</p><p>它们为字符串操作提供了 <code>append</code>、<code>insert</code>、<code>delete</code> 和 <code>substring</code> 方法。</p><table><thead><tr><th align="center">StringBuffer</th><th align="center">StringBuilder</th></tr></thead><tbody><tr><td align="center">线程安全</td><td align="center">非线程安全</td></tr><tr><td align="center">同步</td><td align="center">非同步</td></tr><tr><td align="center">始于 Java 1.0</td><td align="center">始于 Java 1.5</td></tr><tr><td align="center">慢</td><td align="center">快</td></tr></tbody></table><p>在 Java 1.4 之前，StringBuffer 是字符串操作的唯一选择。但是，它的一个缺点是所有公共方法都是同步的。 StringBuffer 提供线程安全性，但以性能为代价。</p><p>在大多数情况下，我们不会在多线程环境中使用 String。所以 Java 1.5 引入了一个新类 StringBuilder，除了线程安全和同步之外，它与 StringBuffer 类似。</p><p>StringBuffer 有一些额外的方法，例如 substring, length, capacity, trimToSize 等。但是，这些不是必需的，因为 String 中也有所有这些。这就是为什么这些方法从未在 StringBuilder 类中实现的原因。</p><p>StringBuffer 是在 Java 1.0 中引入的，而 StringBuilder 类是在查看 StringBuffer 的缺点后在 Java 1.5 中引入的。</p><p>假设在单线程环境中或无关线程安全，要使用 StringBuilder。反之，使用 StringBuffer 进行线程安全的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。</li><li>StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。</li><li>字符串连接运算符 (+) 在内部使用 StringBuilder 类。</li><li>对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。</li></ul><h1 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String所给出的方法均可以直接调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Welcome to Java World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot; sun java &quot;</span>;</span><br><span class="line">System.out.println(s.startsWith(<span class="string">&quot;Welcome&quot;</span>));<span class="comment">//字符串以Welcome开头</span></span><br><span class="line">System.out.println(s.endsWith(<span class="string">&quot;World&quot;</span>));<span class="comment">//字符串以World结尾</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sL</span> <span class="operator">=</span> s.toLowerCase();<span class="comment">//全部转换成小写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sU</span> <span class="operator">=</span> s.toUpperCase();<span class="comment">//全部转换成大写</span></span><br><span class="line">System.out.println(sL);</span><br><span class="line">System.out.println(sU);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> s.substring(<span class="number">11</span>);<span class="comment">//从第十一位开始</span></span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> s.substring(<span class="number">8</span>,<span class="number">11</span>);<span class="comment">//从第八位开始在第十一位结束</span></span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> s1.trim();<span class="comment">//去掉首尾的空格</span></span><br><span class="line">System.out.println(d);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;我是程序员，我在学java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> s2.replace(<span class="string">&quot;我&quot;</span>,<span class="string">&quot;你&quot;</span>);</span><br><span class="line">System.out.println(e);</span><br><span class="line"><span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(f);</span><br><span class="line">System.out.println(s3);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;我是,这的,大王&quot;</span>;</span><br><span class="line">String[] g = s4.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(g[<span class="number">0</span>]);</span><br><span class="line">当把字符串转换成基本类型时，例如，<span class="type">int</span>，integer.praseInt(String s)</span><br><span class="line">当把基本类型转换成字符串时，例如，<span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-中-String、StringBuffer、StringBuilder-的区别&quot;&gt;&lt;a href=&quot;#Java-中-String、StringBuffer、StringBuilder-的区别&quot; class=&quot;headerlink&quot; title=&quot;Java</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-内部类</title>
    <link href="https://cq230.github.io/posts/c17bd6c.html"/>
    <id>https://cq230.github.io/posts/c17bd6c.html</id>
    <published>2021-10-02T12:13:30.000Z</published>
    <updated>2024-12-20T12:23:59.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h2><p>将一个类定义在另一个给类里面或者方法里面，这样的类就被称为内部类。<br>内部类可以分为四种:<strong>成员内部类、局部内部类、匿名内部类、静态内部类</strong>，下面我们逐一介绍这四种内部类。</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>它定义在另一个类中，一般定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为类C相对与类D在外面，我们且称类C为外部类，成员内部类可以无条件访问外部类的属性和方法，但是外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。</p><h3 id="成员内部类无条件访问外部类的属性和方法"><a href="#成员内部类无条件访问外部类的属性和方法" class="headerlink" title="成员内部类无条件访问外部类的属性和方法"></a>成员内部类无条件访问外部类的属性和方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外部类访问内部类属性和方法"><a href="#外部类访问内部类属性和方法" class="headerlink" title="外部类访问内部类属性和方法"></a>外部类访问内部类属性和方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用内部类的属性和方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        System.out.println(d.value);</span><br><span class="line">        d.say();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;DDD&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外部类属性或方法隐藏"><a href="#外部类属性或方法隐藏" class="headerlink" title="外部类属性或方法隐藏"></a>外部类属性或方法隐藏</h3><p>如果成员内部类的属性或者方法与外部类的同名，将导致外部类的这些属性与方法在内部类被隐藏，也可按照该格式调用，外部类.this.属性&#x2F;方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用内部类的属性和方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        System.out.println(d.value);</span><br><span class="line">        d.say();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;DDD&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(C.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建内部类对象"><a href="#创建内部类对象" class="headerlink" title="创建内部类对象"></a>创建内部类对象</h3><p>显然成员内部类是寄生于外部类，创建内部类对象就必须先创造外部类对象。之后创建内部类有两种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*方式1创建成员内部类对象*/</span></span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        C.<span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> c.<span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        <span class="comment">/*方式2创建成员内部类对象*/</span></span><br><span class="line">        C.<span class="type">D</span> <span class="variable">d1</span> <span class="operator">=</span> c.getClassD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;外部类&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类奔跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*创建一个返回D对象的方法*/</span></span><br><span class="line">    <span class="keyword">public</span> D <span class="title function_">getClassD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用内部类的属性和方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        System.out.println(d.value);</span><br><span class="line">        d.say();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;DDD&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;内部类&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(C.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类的访问权限"><a href="#成员内部类的访问权限" class="headerlink" title="成员内部类的访问权限"></a>成员内部类的访问权限</h3><p>成员内部类前可加上四种访问修饰符。<br><strong>private</strong>：仅外部类可访问。<br><strong>protected</strong>：同包下或继承类可访问。<br><strong>default</strong>：同包下可访问。<br><strong>public</strong>：所有类可访问。</p><hr><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类存在于方法中。<br>他和成员内部类的区别在于局部内部类的访问权限仅限于方法或作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">K</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">J</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：局部内部类就像局部变量一样，前面不能访问修饰符以及static修饰符。</p><hr><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>下面我们先通过一段代码初步了解一下匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        driveCar(<span class="keyword">new</span> <span class="title class_">Car</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;驾驶着BMW汽车&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">driveCar</span><span class="params">(Car car)</span>&#123;</span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上代码知道静态方法driveCar需要一个Car对象，我们通过实现接口创建一个匿名类对象传递过去。事实上还可以通过继承类来创建一个匿名内部类对象。<br><strong>注意事项</strong>：匿名内部类没有构造方法。也是唯一没有构造方法的内部类。<strong>匿名内部类和局部内部类只能访问外部类的final变量。</strong></p><hr><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类和成员内部类相比多了一个static修饰符。它与类的静态成员变量一般，是不依赖于外部类的。同时静态内部类也有它的特殊性。因为外部类加载时只会加载静态域，所以静态内部类不能使用外部类的非静态变量与方法。<br>同时可以知道成员内部类里面是不能含静态属性或方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">I</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类的好处"><a href="#内部类的好处" class="headerlink" title="内部类的好处"></a>内部类的好处</h2><ol><li>完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响。</li><li>方便写事件驱动程序。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化bean1</span></span><br><span class="line">        Test15.<span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test15</span>().<span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        bean1.i++;</span><br><span class="line">        <span class="comment">//初始化bean2</span></span><br><span class="line">        Test15.<span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test15</span>.Bean2();</span><br><span class="line">        bean2.j++;</span><br><span class="line">        <span class="comment">//初始化3</span></span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">        Bean.<span class="type">Bean3</span> <span class="variable">bean3</span> <span class="operator">=</span> bean.<span class="keyword">new</span> <span class="title class_">Bean3</span>();</span><br><span class="line">        bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; new 外部类.内部类();</strong><br>成员内部类对象的创建一般是<strong>外部类.内部类 类名 &#x3D; 外部类对象名.new 内部类();</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内部类的定义&quot;&gt;&lt;a href=&quot;#内部类的定义&quot; class=&quot;headerlink&quot; title=&quot;内部类的定义&quot;&gt;&lt;/a&gt;内部类的定义&lt;/h2&gt;&lt;p&gt;将一个类定义在另一个给类里面或者方法里面，这样的类就被称为内部类。&lt;br&gt;内部类可以分为四种:&lt;strong</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-代码块</title>
    <link href="https://cq230.github.io/posts/c0f5e416.html"/>
    <id>https://cq230.github.io/posts/c0f5e416.html</id>
    <published>2021-09-25T11:47:12.000Z</published>
    <updated>2024-12-20T12:23:59.840Z</updated>
    
    <content type="html"><![CDATA[<ol><li>代码块的作用：用来初始化类、对象</li><li>代码块如果有修饰的话，只能是<strong>static</strong></li><li>分类：静态代码块   非静态代码块</li><li>静态代码块：<ul><li>内部可以有输出语句</li><li><strong>随着类的加载而执行，而且只执行一次</strong></li><li>作用：初始化类的信息</li><li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态的代码块中只能调用静态的属性、方法，不能调用非静态的结构</li></ul></li><li>非静态代码块：<ul><li>内部可以有输出语句</li><li><strong>随着对象的创建而执行</strong></li><li><strong>每</strong>创建一个对象，就执行一次<strong>非静态</strong>代码块</li><li>作用：在对象创建时，对对象的属性进行初始化</li><li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>非静态代码块可以调用静态的属性、方法，以及非静态的属性、方法</li></ul></li></ol><h6 id="对属性可以赋值的位置："><a href="#对属性可以赋值的位置：" class="headerlink" title="对属性可以赋值的位置："></a>对属性可以赋值的位置：</h6><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中初始化</li><li>有了对象后，可以通过”对象.属性”或者”对象.方法”的方式，进行赋值</li><li>在代码块中赋值</li></ol><p>执行先后顺序：1 – 2 &#x2F; 5 – 3 – 4</p><p>2和5谁写在前面就先执行谁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;代码块的作用：用来初始化类、对象&lt;/li&gt;
&lt;li&gt;代码块如果有修饰的话，只能是&lt;strong&gt;static&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分类：静态代码块   非静态代码块&lt;/li&gt;
&lt;li&gt;静态代码块：&lt;ul&gt;
&lt;li&gt;内部可以有输出语句&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-enum</title>
    <link href="https://cq230.github.io/posts/eb4f9e04.html"/>
    <id>https://cq230.github.io/posts/eb4f9e04.html</id>
    <published>2021-09-25T11:29:10.000Z</published>
    <updated>2024-12-20T12:23:59.833Z</updated>
    
    <content type="html"><![CDATA[<h6 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shangguiguTest.enumTest;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.枚举类先提供对象，下面再写构造器，</span></span><br><span class="line"><span class="comment">    2.注意对象写法较为省略，多个对象间用“,”，最后一个用“;&quot;</span></span><br><span class="line"><span class="comment">    3.所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">enumTest</span> &#123;</span><br><span class="line">    t1(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),<span class="comment">//t1其实是一个对象，省略了new</span></span><br><span class="line">    t2(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    t3(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    t4(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s1;</span><br><span class="line"></span><br><span class="line">    enumTest(String s, String s1) &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="built_in">this</span>.s1 = s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;&#123;&quot;+this.s+&quot;,&quot;+this.s1+&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shangguiguTest.enumTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">enumTest</span> <span class="variable">tm1</span> <span class="operator">=</span> enumTest.t1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认输出enumTest中常量的名字，除非重写toString()</span></span><br><span class="line">        System.out.println(tm1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;示例代码：&quot;&gt;&lt;a href=&quot;#示例代码：&quot; class=&quot;headerlink&quot; title=&quot;示例代码：&quot;&gt;&lt;/a&gt;示例代码：&lt;/h6&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-封装，继承，多态</title>
    <link href="https://cq230.github.io/posts/d019308f.html"/>
    <id>https://cq230.github.io/posts/d019308f.html</id>
    <published>2021-09-14T11:51:06.000Z</published>
    <updated>2024-12-20T12:23:59.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>get()  set()  方法：</p><p>set（）方法中可以封装对属性的操作</p><h6 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h6><p>A&#x2F;t + insert   可快速生成 get() set() 方法</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li><p>在Java中，所有的类都默认直接或间接继承<strong>Object</strong>类；</p></li><li><p>在Java中只有<strong>单继承</strong>，没有多继承。即一个子类只能有一个父类，而一个父类可以有多个子类；</p></li><li><p>子类能够继承父类哪些属性或方法取决于父类的属性或方法的访问范围，即取决于public、private等修饰符；</p></li><li><p>父类的引用可以指向子类。</p></li></ol><h6 id="IDEA-快捷键"><a href="#IDEA-快捷键" class="headerlink" title="IDEA 快捷键"></a>IDEA 快捷键</h6><p>ctrl + H查看当前类的继承关系</p><p><a href="">this super 关键字</a></p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><ul><li>重写的方法名必须相同；</li><li>重写的方法参数列表必须相同；</li><li>方法的修饰符：范围可以扩大但不能缩小；（public&gt;protected&gt;default&gt;private）</li><li>抛出的异常范围可以被缩小但不能扩大；</li><li>只能是子类重写父类的方法，<strong>不能</strong>重写属性；</li><li>父类的成员方法<strong>只能</strong>被它的子类重写；</li><li>不能重写：声明为<strong>final、static</strong>类型的方法不能重写，但是<strong>static</strong>类型的能够再次声明；</li><li>重写的方法可以使用**@Override**注解来标识；</li><li>子类和父类中的同名同参数的方法要么都声明为非static的（重写），要么都写成static的（<strong>不是重写</strong>）。</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li><p>父类的引用指向子类；</p></li><li><p>子类对父类中某些方法进行重写，在调用这些方法时就会调用子类的方法；</p></li><li><p>不能调用父类中没有的方法；</p></li><li><p>如果子类没有重写父类的方法，则调用父类的方法；如果子类重写了父类的方法，则调用子类的方法；</p></li><li><p>对象的多态性只适用于方法，不适用于属性。</p></li></ol><p>第5条注意：</p><p>若子父类中都有属性age</p><p>父类引用.age的值为父类的age</p><p><strong>语法结构：</strong></p><p>父类名 父类引用 &#x3D; new 子类名();</p><p>父类引用.子类方法();  —&gt;编译时调用父类的方法，运行时调用子类的方法</p><h2 id="多态总结："><a href="#多态总结：" class="headerlink" title="多态总结："></a>多态总结：</h2><ol><li><p>方法：编译看左边，运行看右边；</p></li><li><p>属性：编译运行都看左边；</p></li><li><p>如何使父类对象可以调用子类特有的属性或方法？  </p><p>​需要使用<strong>强制类型转换</strong>，但使用强转时可能出现ClassCastException异常，因此需要用到instanceof关键字</p></li></ol><h1 id="instanceof关键字："><a href="#instanceof关键字：" class="headerlink" title="instanceof关键字："></a>instanceof关键字：</h1><p>a instanceof A：判断对象 a 是否是类 A 的实例；返回 true 或 false</p><p>若类 B 是类 A 的父类，若 a instanceof A 返回 ture, 则 a instanceof B 也返回 ture</p><h5 id="使用情景："><a href="#使用情景：" class="headerlink" title="使用情景："></a>使用情景：</h5><p>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回ture，就进行向下转型，返回false,不进行转型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h1&gt;&lt;p&gt;get()  set()  方法：&lt;/p&gt;
&lt;p&gt;set（）方法中可以封装对属性的操作&lt;/p&gt;
&lt;h6 id=&quot;IDEA快捷键&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-abstract</title>
    <link href="https://cq230.github.io/posts/704a83aa.html"/>
    <id>https://cq230.github.io/posts/704a83aa.html</id>
    <published>2021-09-14T11:06:23.000Z</published>
    <updated>2024-12-20T12:23:59.835Z</updated>
    
    <content type="html"><![CDATA[<h5 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h5><ol><li><p>abstract修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该方法就是抽象类；</p></li><li><p>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类；</p></li><li><p>抽象类，不能用new关键字来创建对象，它是用来让子类继承的；</p></li><li><p>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的；</p></li><li><p>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也必须要声明为抽象类；</p></li><li><p>抽象类中可以写普通方法；</p></li><li><p>抽象类中一定有构造器;</p></li><li><p>注意匿名类的写法。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;关键字：abstract&quot;&gt;&lt;a href=&quot;#关键字：abstract&quot; class=&quot;headerlink&quot; title=&quot;关键字：abstract&quot;&gt;&lt;/a&gt;关键字：abstract&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;abstract修饰符可以用来修饰方法也可</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
</feed>
