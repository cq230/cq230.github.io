<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白开水船长</title>
  
  <subtitle>东隅已逝，桑榆非晚</subtitle>
  <link href="https://cq230.github.io/atom.xml" rel="self"/>
  
  <link href="https://cq230.github.io/"/>
  <updated>2024-12-20T10:33:57.866Z</updated>
  <id>https://cq230.github.io/</id>
  
  <author>
    <name>Ryan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-interface</title>
    <link href="https://cq230.github.io/posts/9a542ee1.html"/>
    <id>https://cq230.github.io/posts/9a542ee1.html</id>
    <published>2021-12-30T09:16:24.000Z</published>
    <updated>2024-12-20T10:33:57.866Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义接口：定义接口中的成员</p><p><del>JDK7及以前：接口中只能定义全局常量和抽象方法：</del></p><p><del><strong>全局常量</strong>：public static final 的，但是在接口中书写时，可以省略不写；</del></p><p><del><strong>抽象方法</strong>：public abstract 的。</del></p><p>JDK8：除了全局常量和抽象方法，还可以定义静态方法、默认方法，二者可以<strong>有方法体</strong>：</p><ul><li><p><strong>静态方法：</strong>只能通过接口来调用；</p></li><li><p><strong>默认方法：</strong></p><ul><li><p>通过<strong>实现类的对象</strong>，可以调用接口中的<strong>默认方法</strong>；如果实现类重写了接口中的默认方法，调用时仍然调用的是重写后的方法；</p></li><li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类在没有重写此方法的情况下会报错。——&gt; <strong>接口冲突</strong>。这就需要我们在实现类中重写此方法；</p></li><li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数方法。——&gt;<strong>类优先原则</strong></p><p> 注意：类优先原则<strong>仅针对方法</strong>，不包括属性，见下方面试题1</p></li><li><p><strong>规定</strong>：在子类（或实现类）的方法中可以调用父类、接口中<strong>被子类重写</strong>的方法，语法如下（见代码演示1）：</p><p> ​super.testFunc();            &#x2F;&#x2F;调用父类中声明的方法</p><p> ​接口.super.testFunc();   &#x2F;&#x2F; 调用接口中声明的默认方法</p></li><li><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=359&share_source=copy_web">静态方法及默认方法讲解视频</a></p></li></ul></li></ul></li><li><p>接口中<strong>不能定义构造器</strong>，意味着接口不能被实例化；</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用；</p></li><li><p>如果一个实现类中覆盖了接口中的<strong>所有</strong>抽象方法，则此实现类<strong>可以</strong>被实例化；</p><p>如果实现类没有覆盖接口中的所有抽象方法，则此实现类<strong>仍为一个抽象类</strong>。</p></li><li><p>Java<strong>类可以实现多个接口</strong> —&gt; 弥补了Java单继承的局限性；</p><p>格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以<strong>多继承</strong>；</p></li><li><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=354&share_source=copy_web">接口的四种实现方式：</a>（匿名类与匿名对象）</p></li></ol><h4 id="接口面试题："><a href="#接口面试题：" class="headerlink" title="接口面试题："></a>接口面试题：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(x); //编译不通过，对 &#x27;x&#x27; 的引用不明确，&#x27;B.x&#x27; 和 &#x27;A.x&#x27; 均匹配</span></span><br><span class="line"></span><br><span class="line">        System.out.println(A.x); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.x); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>().myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>); <span class="comment">// A 重写了此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        testFunc();         <span class="comment">// A (调用的是自己重写后的方法)</span></span><br><span class="line">        <span class="built_in">super</span>.testFunc();   <span class="comment">// B (调用的是父类中被重写的方法)</span></span><br><span class="line">        C.<span class="built_in">super</span>.testFunc(); <span class="comment">// C (调用的是接口中被重写的方法)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> &#123;</span><br><span class="line">     <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义接口：定义接口中的成员&lt;/p&gt;
&lt;p&gt;&lt;del&gt;JDK7及以前：接口中只能定义全局常量和抽象方法：&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;&lt;strong&gt;全局常量&lt;/strong&gt;：public static final 的，但是在接口中书写时，可以省略</summary>
      
    
    
    
    <category term="编程学习" scheme="https://cq230.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://cq230.github.io/tags/Java/"/>
    
    <category term="Java 关键字" scheme="https://cq230.github.io/tags/Java-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    <category term="Java 基础" scheme="https://cq230.github.io/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编程" scheme="https://cq230.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
